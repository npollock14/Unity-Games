// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5474.DrDank.commands;

//import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import org.usfirst.frc5474.DrDank.Robot;

/**
 *
 */
public class AutonomousCommandRight extends Command {

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	private Timer autonStateTimer;
	private int autonState;
	private final static int AUTON_STATE_DRIVE_FORWARD = 1;
	private final static int AUTON_STATE_TURN = 2;
	private final static int AUTON_STATE_ACROSS = 3;
	private final static int AUTON_STATE_TURN_SWITCH = 4;
	private final static int AUTON_STATE_GO_TO_SWITCH = 5;
	private final static int AUTON_STATE_FINISHED = 6;
	int executing;
	double UDpower;
	double LRpower;
	double time;

	String gameData;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
	public AutonomousCommandRight() {

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	private void changeAutonState(int nextState) {
		if (nextState != autonState) {
			autonState = nextState;
			autonStateTimer.reset();
		}
	}

	// Called just before this Command runs the first time
	@Override
	protected void initialize() {

		autonState = AUTON_STATE_DRIVE_FORWARD;
		autonStateTimer = new Timer();
		autonStateTimer.start();
		executing = 0;
		
		

	}

	// Called repeatedly when this Command is scheduled to run
	@Override
	protected void execute() {
		executing = executing + 1;
		SmartDashboard.putNumber("executing", executing);
		SmartDashboard.putNumber("State", autonState);

		switch (autonState) {
		case AUTON_STATE_DRIVE_FORWARD: {
//			time = 1.43;
			time = 1.00;
			UDpower = 0.7;
			SmartDashboard.putString("forward", ""); 
			
			Robot.driveSub.driveDrDankStraight(UDpower);

			if (autonStateTimer.hasPeriodPassed(time)) {
				changeAutonState(AUTON_STATE_TURN);
				SmartDashboard.putNumber("forward", autonStateTimer.get());
			}
		}
			break;
		case AUTON_STATE_TURN: {
			LRpower = 0.7;
						
			gameData=DriverStation.getInstance().getGameSpecificMessage();
	    	SmartDashboard.putString("GameData", gameData);
	    	if(gameData.charAt(0)=='R')
	    		{time = 0;}
	    	else
	    	    {time = 0.6;
	    		Robot.driveSub.driveDrDankLeft(LRpower);}

			if (autonStateTimer.hasPeriodPassed(time)) {
				changeAutonState(AUTON_STATE_ACROSS);
				SmartDashboard.putNumber("turn", autonStateTimer.get());
			}
		}
			break;
		case AUTON_STATE_ACROSS: {
			UDpower = 0.7;
			//SmartDashboard.putString("switch", "");
			if(gameData.charAt(0)=='R')
    			{time = 0;}
			else
    	    	{time = 1.72;
    	    	Robot.driveSub.driveDrDankStraight(LRpower);}
						
			if (autonStateTimer.hasPeriodPassed(time)) {
				changeAutonState(AUTON_STATE_TURN_SWITCH);
				SmartDashboard.putNumber("finish", autonStateTimer.get());
			}
		}
			break;
		case AUTON_STATE_TURN_SWITCH: {
			LRpower = 0.7;
						
			gameData=DriverStation.getInstance().getGameSpecificMessage();
	    	//SmartDashboard.putString("GameData", gameData);
	    	if(gameData.charAt(0)=='R')
	    		{time = 0;}
	    	else
	    	    {time = 0.6;
	    		Robot.driveSub.driveDrDankRight(LRpower);}

			if (autonStateTimer.hasPeriodPassed(time)) {
				changeAutonState(AUTON_STATE_GO_TO_SWITCH);
				SmartDashboard.putNumber("turn", autonStateTimer.get());
			}
		}
			break;
		case AUTON_STATE_GO_TO_SWITCH: {
			time = 0.9;
			UDpower = 0.7;
			SmartDashboard.putString("switch", "");
			gameData=DriverStation.getInstance().getGameSpecificMessage();
			Robot.driveSub.driveDrDankStraight(UDpower);	
			
			if (autonStateTimer.hasPeriodPassed(time)) {
				changeAutonState(AUTON_STATE_FINISHED);
				SmartDashboard.putNumber("finish", autonStateTimer.get());
			}
		}
			break;
		case AUTON_STATE_FINISHED: {
			Robot.driveSub.stopDrDank();
			//Drop the box after
		}
		break;
	}

	}

	// Make this return true when this Command no longer needs to run execute()
	@Override
	protected boolean isFinished() {
		return false;
	}

	// Called once after isFinished returns true
	@Override
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	@Override
	protected void interrupted() {
	}
}
